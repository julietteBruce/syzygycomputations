installPackage "HirzebruchSyzygies"
load "conjectures.m2"

-----INPUT: A partition {a,b} and a nonnegative integer d.
-----
-----OUTPUT: A list of partitions generated by applying the Pieri rule to S_{a,b} \otimes S_{-d}
-----
-----DESCRIPTION: You give this function a tableau (a,b) and the number of boxes you wish to remove
-----from that tableau d. This computes S_{a,b} \otimes S_{-d} using the Pieri rule.

pieriP1 = (a,b,d)->(
    boxList = apply(d+1, i-> {i,d-i});
    keepers = (L,D)->(
    	L_0 - D_0 >= L_1 and L_1 - D_1 >= 0
    	);
    outputList = {};
    scan(boxList, D-> if keepers({a,b},D) == true then outputList = outputList|{{a,b}-D});
    outputList
    )


-----INPUT: Partitions {x0,y0},{x1,y1} and nonnegative integers d0,d1.
-----
-----OUTPUT: A list of 4-tuples representing pairs of partitions corresponding to the decompositions
-----of S_{x_0,y_0} \otimes S_{-d_0} and S_{x_1,y_1) \otimes S_{-d_1} into irreducibles as representations
-----of GL_2 x GL_2.
-----
-----DESCRIPTION: This takes an irreducible representation of P1xP1 given by a pair of partitions
-----(x0,y0), (x1,y1) and generates a list of all the pairs of partitions corresponding to
-----S_{x0,y0} \otimes S_{-d_0} and S_{x1,y1} \otimes S_{-d_1}.

pieriP1P1 = (x0,y0,x1,y1,d0,d1)->(
    firstSchurFunctors = pieriP1(x0,y0,d0);
    secondSchurFunctors = pieriP1(x1,y1,d1);
    outputList = {};
    scan(firstSchurFunctors, S -> scan(secondSchurFunctors, D -> outputList = outputList|{S|D}));
    outputList
    )


----- INPUT: (a,B,D,q)
-----
----- OUPUT: True or false. True if the last entry in the q-th row of the Betti table for
-----	     	 (a,B,D) generates the second to last entry using the Pieri rule.
-----
----- DESCRIPTION: This checks whether the last entry in row q of the Betti Table
-----	     	 for (a,B,D) could generate the second to last entry using the
-----    	 Pieri rule.

checkGeneration = method();
checkGeneration (ZZ,List,List,ZZ) := (a,B,D,q) -> (
    output = false;
    lastEntry = lastSchurEntry(a,B,D,q);
    secondLastEntry = secondLastSchurEntry(a,B,D,q);
    secondLastEntrySchur = {};
    scan(secondLastEntry, S-> secondLastEntrySchur = secondLastEntrySchur|{S_0});
    generatesSchur = {};
    scan(lastEntry, S -> generatesSchur = generatesSchur|pieriP1P1((S_0)_0,(S_0)_1,(S_0)_2,(S_0)_3,D_0,D_1));
    generatesSchur = rsort(generatesSchur);
    generates = new MutableHashTable from {};
    scan(generatesSchur, S -> if not isSubset(S,keys(generates)) then generates#S = number(generatesSchur,i -> i==S));
    if isSubset(secondLastEntrySchur,generatesSchur) then(
	output = true;
	scan(secondLastEntry, S-> if generates#(S_0) < S_1 then output = false);
	);
    output
    )

----- INPUT: (a,B,D,P)
-----
----- OUPUT: Pair (True/False, True/False) First True/False if the entry in the P={p,q} position of the Betti table for
-----	     	 (a,B,D) generates the {p-1,q} entry using the Pieri rule account for multiplicites. Second True/False
-----	     	 if we generate without account for multiplicities (so just looking at the pairs of partitions that appear).
-----
----- DESCRIPTION: This checks whether the {p,q} entry in the Betti Table
-----	     	 for (a,B,D) could generate the {p-1,q} entry using the
-----    	 Pieri rule.

checkGenAny = method();
checkGenAny (ZZ,List,List,List) := (a,B,D,P) -> (
    output = false;
    totalSchurBettiT = schurBetti(a,B,D);
    lastEntry = (totalSchurBettiT)#(toSequence(P));
    secondLastEntry = (totalSchurBettiT)#(toSequence(P-{1,0}));
    secondLastEntrySchur = {};
    scan(secondLastEntry, S-> secondLastEntrySchur = secondLastEntrySchur|{S_0});
    generatesSchur = {};
    scan(lastEntry, S -> generatesSchur = generatesSchur|pieriP1P1((S_0)_0,(S_0)_1,(S_0)_2,(S_0)_3,D_0,D_1));
    generatesSchur = rsort(generatesSchur);
    generates = new MutableHashTable from {};
    scan(generatesSchur, S -> if not isSubset(S,keys(generates)) then generates#S = number(generatesSchur,i -> i==S));
    necessaryPartitions = isSubset(secondLastEntrySchur,generatesSchur);
    if necessaryPartitions then(
	output = true;
	scan(secondLastEntry, S-> if generates#(S_0) < S_1 then output = false);
	);
    output, necessaryPartitions
    )

--------------------------------------------------------------------
--------------------------------------------------------------------
----- INPUT: (a,B,D,q)
-----
----- OUPUT: By default a sequence (p,q) such that K_{p,q}(a,B,D)
----- is non-zero, but K_{p+1,q}(a,B,D) is equal to zero. If
----- the option Value=>true is used the value of K_{p+1,q}(a,B,D)
----- is also returned 
-----
----- DESCRIPTION: This function is finds the last non-zero entry
----- in the q-th row of the Betti table for (a,B,D). This is done 
----- using our computational data, i.e. totalBetti(a,B,D) is loaded.
-----
----- CAVEAT: Note that if the request row is empty then the index
----- returned is -infinity.
--------------------------------------------------------------------
--------------------------------------------------------------------
firstNonzeroEntry = method(Options => {Value => false});
firstNonzeroEntry  (ZZ,List,List,ZZ) := opts -> (a,B,D,q) ->(
    H =  totalBetti(a,B,D);
    firstKey = min delete(,apply(keys H, k->(
	    if k#1 == q and H#k !=0 then k
	    ))); 
    if opts.Value == false then ( 
	return firstKey 
	);
    if opts.Value == true then ( 
	return {firstKey,H#firstKey} 
	); 
    )

--------------------------------------
----- INPUT: (a,B,D,q)
-----
----- OUPUT: A list of pairs (True/False,True/False,ZZ). If (True/False,True/False, p), this means that the Schur decomposition for
----- (p,q) generates/doesn't generate the Schur decomp for (p-1,q) using the Pieri rule where the first True/False
----- accounts for multiplicites and the second does not.
-----
-----
----- DESCRIPTION: This checks which positions in the Betti Table for (a,B,D) in row q can generate the
----- previous position using the pieri rule.
--------------------------------------

checkGenRow = method();
checkGenRow (ZZ,List,List,ZZ) := (a,B,D,q) -> (
    output = {};
    genStart = {};
    P = toList(lastNonzeroEntry(a,B,D,q));
    scan(0..(P_0-(firstNonzeroEntry(a,B,D,q))_0-1), i -> output = output|{(checkGenAny(a,B,D,{P_0-i,q}),P_0-i)});
--	    if (output == true and oldOutput == false) then genStart = P;
    output
    )
	

end
------------------------

--Should return true:
checkGeneration(0,{0,0},{2,5},1)

--Should return false since there is a Schur functor not generated.
checkGeneration(0,{0,0},{3,4},1)

--One can check the above by noticing that lastSchurEntry(0,{0,0},{3,4},1) = {({24, 24, 39, 25}, 1)
--while secondLastSchurEntry(0,{0,0},{3,4},1) = {({29, 16, 30, 30}, 1), ({24, 21, 38, 22}, 1), 
--({24, 21, 37, 23}, 1), ({24, 21, 36, 24}, 1),({24,21,35,25,},1)}. The first entry is not generated.



checkGenRow(0,{0,0},{1,2},1) --All True
checkGenRow(0,{0,0},{1,3},1) --All True
checkGenRow(0,{0,0},{1,4},1) --All True 
checkGenRow(0,{0,0},{1,5},1) --True after p = 3 ?? Gens in 9, 5, 3
checkGenRow(0,{0,0},{1,6},1) --True after p = 3 Gens in 11, 7, 6, 5, 4, 3
checkGenRow(0,{0,0},{1,7},1)
checkGenRow(0,{0,0},{2,3},1) --True after p = 5
checkGenRow(0,{0,0},{2,3},2) --All True
checkGenRow(0,{0,0},{3,4},2) --True
checkGenRow(0,{0,0},{3,4},1) 


schurBetti(0,{0,0},{1,5})

checkGenAny(0,{0,0},{1,5},{6,1})


Second Entry True q = 1 row:
{1,2} -- 0
{1,3} -- 0
{1,4} -- 0
{1,5} -- 0
{1,6} -- 0
{1,7} -- 0
{1,8} -- 0
{2,3} -- 1
{2,4} -- 2
{2,5} -- 3
{2,6} -- 4
{2,7} -- 5
{2,8} -- 6
{3,4} -- 2
{3,5} -- 3

(d_2-d_1) * (d_1 -1)





